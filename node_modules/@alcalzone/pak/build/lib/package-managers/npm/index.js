"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Npm = void 0;
const axios_1 = __importDefault(require("axios"));
const execa_1 = __importDefault(require("execa"));
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const package_manager_1 = require("../package-manager");
const exactVersionRegex = /.+@\d+/;
function fail(message) {
    return {
        success: false,
        exitCode: 1,
        stdout: "",
        stderr: message,
        stdall: message,
    };
}
async function resolveDependency(dependency, version) {
    let reg;
    try {
        reg = (await axios_1.default.get(`https://registry.npmjs.org/${dependency}`))
            .data;
    }
    catch (e) {
        throw new Error(`Failed to download package info from npm registry: ${e.message}`);
    }
    if (version in reg.versions) {
        const versionInfo = reg.versions[version];
        return {
            version: versionInfo.version,
            dependencies: versionInfo.dependencies,
            integrity: versionInfo.dist.integrity,
            tarball: versionInfo.dist.tarball,
        };
    }
    else {
        throw new Error(`${dependency}@${version} was not found in the npm registry!`);
    }
}
function overrideV1(original, override) {
    const ret = Object.assign({}, original);
    ret.version = override.version;
    if (ret.tarball) {
        ret.tarball = override.tarball;
    }
    else {
        ret.resolved = override.tarball;
        if (override.integrity)
            ret.integrity = override.integrity;
    }
    ret.requires = override.dependencies;
    return ret;
}
function overrideV2(original, override) {
    const ret = Object.assign({}, original);
    ret.version = override.version;
    if (ret.tarball) {
        ret.tarball = override.tarball;
    }
    else {
        ret.resolved = override.tarball;
        if (override.integrity)
            ret.integrity = override.integrity;
        else
            delete ret.integrity;
    }
    ret.dependencies = override.dependencies;
    return ret;
}
function walkLockfileV1(root, dir, overrides, affectedPackageJsons) {
    if (!("dependencies" in root))
        return;
    for (const dep of Object.keys(root.dependencies)) {
        if (dep in overrides) {
            // Replace the overrides
            root.dependencies[dep] = overrideV1(root.dependencies[dep], overrides[dep]);
        }
        else {
            const depRoot = root.dependencies[dep];
            if ("requires" in depRoot) {
                let wasChanged = false;
                for (const [ovrr, { version }] of Object.entries(overrides)) {
                    if (ovrr in depRoot.requires) {
                        depRoot.requires[ovrr] = version;
                        wasChanged = true;
                    }
                }
                if (wasChanged) {
                    // The package is affected, update it and remember where its package.json is
                    affectedPackageJsons.add(path.join(dir, "node_modules", dep, "package.json"));
                }
            }
            // and recursively continue with the other packages that might use them
            walkLockfileV1(root.dependencies[dep], path.join(dir, "node_modules", dep), overrides, affectedPackageJsons);
        }
    }
}
function walkLockfileV2(root, dir, overrides, affectedPackageJsons) {
    var _a;
    if (!("packages" in root))
        return;
    // Lockfile v2 stores a package structure
    for (const pkg of Object.keys(root.packages)) {
        const pkgRoot = root.packages[pkg];
        const name = (_a = pkgRoot.name) !== null && _a !== void 0 ? _a : pkg.substr(pkg.lastIndexOf("node_modules/") + 13);
        if (name in overrides) {
            // Replace the overrides
            root.packages[pkg] = overrideV2(root.packages[pkg], overrides[name]);
        }
        else if ("dependencies" in pkgRoot) {
            let wasChanged = false;
            for (const [ovrr, { version }] of Object.entries(overrides)) {
                if (ovrr in pkgRoot.dependencies) {
                    pkgRoot.dependencies[ovrr] = version;
                    wasChanged = true;
                }
            }
            if (wasChanged) {
                // The package is affected, update it and remember where its package.json is
                affectedPackageJsons.add(path.join(dir, pkg, "package.json"));
            }
        }
    }
}
class Npm extends package_manager_1.PackageManager {
    /** Executes a "raw" npm command */
    async command(args, options = {}) {
        var _a, _b, _c, _d, _e, _f;
        const promise = (0, execa_1.default)("npm", args, Object.assign(Object.assign({}, options), { cwd: this.cwd, reject: false, all: true }));
        // Pipe command outputs if desired
        if (this.stdout)
            (_a = promise.stdout) === null || _a === void 0 ? void 0 : _a.pipe(this.stdout, { end: false });
        if (this.stderr)
            (_b = promise.stderr) === null || _b === void 0 ? void 0 : _b.pipe(this.stderr, { end: false });
        if (this.stdall)
            (_c = promise.all) === null || _c === void 0 ? void 0 : _c.pipe(this.stdall, { end: false });
        // Execute the command
        const result = await promise;
        // Unpipe the command outputs again, so the process can end
        (_d = promise.stdout) === null || _d === void 0 ? void 0 : _d.unpipe();
        (_e = promise.stderr) === null || _e === void 0 ? void 0 : _e.unpipe();
        (_f = promise.all) === null || _f === void 0 ? void 0 : _f.unpipe();
        // Translate the returned result
        return (0, package_manager_1.execaReturnValueToCommandResult)(result);
    }
    /** Installs the given packages using npm */
    install(packages = [], options = {}) {
        const args = ["install"];
        if (options.dependencyType === "dev") {
            args.push("--save-dev");
        }
        if (options.exact || packages.some((p) => exactVersionRegex.test(p))) {
            args.push("--save-exact");
        }
        if (options.global)
            args.push("--global");
        if (this.loglevel) {
            args.push("--loglevel", this.loglevel);
        }
        args.push(...packages);
        if (packages.length === 0) {
            if (this.environment === "production") {
                args.push("--production");
            }
            if (options.ignoreScripts) {
                args.push("--ignore-scripts");
            }
        }
        if (options.additionalArgs) {
            args.push(...options.additionalArgs);
        }
        return this.command(args);
    }
    uninstall(packages, options = {}) {
        const args = ["uninstall"];
        if (options.dependencyType === "dev") {
            args.push("--save-dev");
        }
        if (options.global)
            args.push("--global");
        if (this.loglevel) {
            args.push("--loglevel", this.loglevel);
        }
        args.push(...packages);
        if (options.additionalArgs) {
            args.push(...options.additionalArgs);
        }
        return this.command(args);
    }
    update(packages = [], options = {}) {
        const args = ["update"];
        if (options.dependencyType === "dev") {
            args.push("--save-dev");
        }
        if (options.global)
            args.push("-g");
        if (this.loglevel) {
            args.push("--loglevel", this.loglevel);
        }
        args.push(...packages);
        return this.command(args);
    }
    rebuild(packages = []) {
        const args = ["rebuild"];
        if (this.loglevel) {
            args.push("--loglevel", this.loglevel);
        }
        args.push(...packages);
        return this.command(args);
    }
    async detect(requireLockfile = true, setCwdToPackageRoot = false) {
        try {
            const root = await this.findRoot(requireLockfile ? "package-lock.json" : undefined);
            if (setCwdToPackageRoot)
                this.cwd = root;
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    async version() {
        const result = await this.command(["-v"]);
        if (!result.success) {
            throw new Error(`Could not detect npm version: ${result.stderr}! Exit code: ${result.exitCode}.`);
        }
        return result.stdout;
    }
    async overrideDependencies(dependencies) {
        // In order to override dependency versions in npm, we need to do the following things:
        // 1. Update the definition(s) of the updated package in package-lock.json. These are objects under ...->"dependencies"
        // 2. Find all packages that use the package, edit their local package.json to point to the new version
        // 3. run `npm install` in the root dir. This updates package-lock.json with the versions from the local package.json files
        let root;
        let rootPackageJsonPath;
        let rootPackageLockPath;
        // let rootPackageJson: Record<string, any>;
        let rootPackageLock;
        try {
            root = await this.findRoot("package-lock.json");
            rootPackageJsonPath = path.join(root, "package.json");
            // rootPackageJson = await fs.readJson(rootPackageJsonPath, {
            // 	encoding: "utf8",
            // });
            rootPackageLockPath = path.join(root, "package-lock.json");
            rootPackageLock = await fs.readJson(rootPackageLockPath, {
                encoding: "utf8",
            });
        }
        catch (e) {
            return fail(`Error loading root package.json and package-lock.json: ${e.message}`);
        }
        if (rootPackageLock.lockfileVersion !== 1 &&
            rootPackageLock.lockfileVersion !== 2) {
            return fail(`Lockfile version ${rootPackageLock.lockfileVersion} is not supported!`);
        }
        // Look up the information for our overrides
        const overrides = {};
        for (const [dep, version] of Object.entries(dependencies)) {
            try {
                overrides[dep] = await resolveDependency(dep, version);
            }
            catch (e) {
                return fail(e.message);
            }
        }
        // Walk through the lockfile, edit it and find the package.jsons we need to update
        const affectedPackageJsons = new Set();
        affectedPackageJsons.add(rootPackageJsonPath);
        if (rootPackageLock.lockfileVersion === 2) {
            walkLockfileV2(rootPackageLock, root, overrides, affectedPackageJsons);
        }
        if (rootPackageLock.lockfileVersion <= 2) {
            // V2 contains backwards compatibility data for V1 we also need to edit
            walkLockfileV1(rootPackageLock, root, overrides, affectedPackageJsons);
        }
        try {
            for (const packPath of affectedPackageJsons) {
                // Update each possibly affected package.json
                const pack = await fs.readJson(packPath, {
                    encoding: "utf8",
                });
                if (!pack.dependencies)
                    continue;
                let wasChanged = false;
                for (const [dep, { version }] of Object.entries(overrides)) {
                    if (dep in pack.dependencies) {
                        pack.dependencies[dep] = version;
                        wasChanged = true;
                    }
                }
                // And save it
                if (wasChanged) {
                    await fs.writeJson(packPath, pack, {
                        spaces: 2,
                        encoding: "utf8",
                    });
                }
            }
            // Save package-lock.json last
            await fs.writeJson(rootPackageLockPath, rootPackageLock, {
                spaces: 2,
                encoding: "utf8",
            });
        }
        catch (e) {
            return fail(`Error updating package files: ${e.message}`);
        }
        // Running "npm install" in the root dir will now install the correct dependencies
        const prevCwd = this.cwd;
        this.cwd = root;
        try {
            debugger;
            const ret = await this.install();
            // Force npm to restore the original structure
            await this.command(["dedupe"]);
            return ret;
        }
        finally {
            this.cwd = prevCwd;
        }
    }
}
exports.Npm = Npm;
//# sourceMappingURL=index.js.map