/// <reference types="node" />
import type { ExecaReturnValue } from "execa";
import type { Writable } from "stream";
export declare abstract class PackageManager {
    /**
     * Tests if this package manager should be active in the current directory.
     * @param requireLockfile Whether a matching lockfile must be present for the check to succeed
     * @param setCwdToPackageRoot Whether the cwd of the package manager should be set to the directory where the lockfile or package.json was found
     */
    abstract detect(requireLockfile?: boolean, setCwdToPackageRoot?: boolean): Promise<boolean>;
    /** Installs the specified packages */
    abstract install(packages?: string[], options?: InstallOptions): Promise<CommandResult>;
    /** Uninstalls the specified packages */
    abstract uninstall(packages: string[], options?: UninstallOptions): Promise<CommandResult>;
    /** Updates the specified packages or all of them if none are specified */
    abstract update(packages?: string[], options?: UpdateOptions): Promise<CommandResult>;
    /** Rebuilds the specified native packages or all of them if none are specified */
    abstract rebuild(packages?: string[]): Promise<CommandResult>;
    /** Returns the active version of the package manager */
    abstract version(): Promise<string>;
    /** Finds the closest parent directory that contains a package.json and the corresponding lockfile (if one was specified) */
    findRoot(lockfile?: string): Promise<string>;
    /** Forces the given dependency versions to be installed, rather than what the official packages require */
    abstract overrideDependencies(dependencies: Record<string, string>): Promise<CommandResult>;
    /** The directory to run the package manager commands in */
    cwd: string;
    /** Which loglevel to pass to the package manager */
    loglevel?: "info" | "verbose" | "warn" | "error" | "silent";
    /** The (optional) stream to pipe the command's stdout into */
    stdout?: Writable;
    /** The (optional) stream to pipe the command's stderr into */
    stderr?: Writable;
    /**
     * The (optional) stream to pipe the command's entire output (stdout + stderr) into.
     * If this is set, stdout and stderr will be ignored
     */
    stdall?: Writable;
    /**
     * The environment the package manager is executed in (default: "production").
     * In an production environment, `pak` avoids accidentally pulling in `devDependencies`.
     */
    environment: "production" | "development";
}
export interface InstallBaseOptions {
    /** Whether to install a production or dev dependency. Default: "prod" */
    dependencyType?: "prod" | "dev";
    /** Whether to install the package globally. Default: false */
    global?: boolean;
    /** Additional command line args to pass to the underlying package manager. Default: none */
    additionalArgs?: string[];
}
export interface InstallOptions extends InstallBaseOptions {
    /** Whether exact versions should be used instead of "^ver.si.on". Default: false */
    exact?: boolean;
    /** Prevent execution of pre/post/install scripts. Default: false (execute scripts) */
    ignoreScripts?: boolean;
}
export declare type UninstallOptions = InstallBaseOptions;
export declare type UpdateOptions = InstallBaseOptions;
export interface CommandResult {
    /** Whether the command execution was successful */
    success: boolean;
    /** The exit code of the command execution */
    exitCode: number;
    /** The captured stdout */
    stdout: string;
    /** The captured stderr */
    stderr: string;
    /** The captured stdout and stderr, interleaved like it would appear on the console */
    stdall: string;
}
export declare function execaReturnValueToCommandResult(result: ExecaReturnValue): CommandResult;
