"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const pak_1 = require("@alcalzone/pak");
const release_script_core_1 = require("@alcalzone/release-script-core");
const typeguards_1 = require("alcalzone-shared/typeguards");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const semver_1 = __importDefault(require("semver"));
function getEffectivePublishAllFlag(context) {
    var _a, _b, _c;
    const oldVersion = context.getData("version");
    const newVersion = context.getData("version_new");
    // Force a publish of all packages if the version changed from a prerelease to a stable version
    let publishAll = context.argv.publishAll;
    if (!publishAll &&
        semver_1.default.gt(newVersion, oldVersion) &&
        ((_a = semver_1.default.parse(newVersion)) === null || _a === void 0 ? void 0 : _a.prerelease.length) === 0 &&
        ((_c = (_b = semver_1.default.parse(oldVersion)) === null || _b === void 0 ? void 0 : _b.prerelease.length) !== null && _c !== void 0 ? _c : 0) > 0) {
        publishAll = true;
    }
    return publishAll;
}
async function getUpdatePackages(context, publishAll, oldVersion) {
    const { stdout: output } = await context.sys.exec("yarn", publishAll
        ? ["workspaces", "list", "--json"]
        : ["changed", "list", "--json", `--git-range=v${oldVersion}`], { cwd: context.cwd });
    const updatePackages = output
        .trim()
        .split("\n")
        .map((line) => line.trim())
        .filter(Boolean)
        .map((line) => JSON.parse(line));
    return updatePackages;
}
class PackagePlugin {
    constructor() {
        this.id = "package";
        this.stages = [release_script_core_1.DefaultStages.check, release_script_core_1.DefaultStages.edit, release_script_core_1.DefaultStages.commit];
        // The lockfile needs to be synchronized after bumping, but before the final commit
        this.stageBefore = {
            commit: ["git"],
        };
        this.stageAfter = {
            commit: (context) => {
                // In lerna mode, we need to update the lockfile after bumping, so we do that in non-lerna mode too.
                const lerna = context.hasData("lerna") && !!context.getData("lerna");
                if (lerna)
                    return ["lerna"];
                return [];
            },
        };
    }
    defineCLIOptions(yargs) {
        return yargs.options({
            updateLockfile: {
                alias: ["update-lockfile", "l"],
                description: "Update the lockfile before committing",
                type: "boolean",
                default: true,
            },
        });
    }
    async executeCheckStage(context) {
        // ensure that package.json exists and has a version (unless in lerna mode)
        const packPath = path_1.default.join(context.cwd, "package.json");
        if (!(await fs_extra_1.default.pathExists(packPath))) {
            context.cli.fatal("No package.json found in the current directory!");
        }
        const pack = await fs_extra_1.default.readJson(packPath);
        // Check if the current project is a monorepo
        const isMonorepo = "workspaces" in pack && (0, typeguards_1.isArray)(pack.workspaces) && pack.workspaces.length > 0;
        const lerna = context.hasData("lerna") && !!context.getData("lerna");
        if (isMonorepo) {
            if (lerna) {
                // ok, continue
            }
            else {
                // we need some yarn plugins to be able to handle this
                const yarnRcPath = path_1.default.join(context.cwd, ".yarnrc.yml");
                if (await fs_extra_1.default.pathExists(yarnRcPath)) {
                    const yarnRc = await fs_extra_1.default.readFile(yarnRcPath, "utf8");
                    const yarnPlugins = yarnRc
                        .split("\n")
                        .map((line) => line.trim())
                        .filter((line) => !!line && !line.startsWith("#"))
                        .filter((line) => line.includes("path: "))
                        .map((line) => line
                        .substring(line.indexOf("@yarnpkg/"))
                        .replace(/^@yarnpkg\/plugin-/, "")
                        .replace(/\.cjs$/, ""));
                    // A list of required plugins and how to import them
                    const requiredPlugins = {
                        "workspace-tools": "workspace-tools",
                        version: "version",
                        changed: "https://github.com/Dcard/yarn-plugins/releases/latest/download/plugin-changed.js",
                    };
                    const missingPlugins = Object.keys(requiredPlugins).filter((plugin) => !yarnPlugins.includes(plugin));
                    // context.cli.log(`Installed yarn plugins: ${yarnPlugins.join(", ")}`);
                    if (missingPlugins.length > 0) {
                        context.cli.fatal(`The current project is a monorepo, which seems to be managed with yarn. The release script requires you to install additional yarn plugins to be able to handle this:
${context.cli.colors.blue(missingPlugins.map((plugin) => `\nyarn plugin import ${requiredPlugins[plugin]}`).join(""))}

Alternatively, you can use ${context.cli.colors.blue("lerna")} to manage the monorepo.`);
                    }
                    // All good, remember that we use yarn to manage the monorepo
                    context.setData("monorepo", "yarn");
                    // One last check: make sure there is anything to publish
                    // We cannot use getEffectivePublishAllFlag here without introducing a circular dependency
                    const publishAll = context.argv.publishAll;
                    const updatePackages = await getUpdatePackages(context, publishAll, pack.version);
                    if (!updatePackages.length) {
                        context.cli.fatal(`The current project is a monorepo, but no packages were changed! To force a release anyways, use the "--publishAll" flag!`);
                    }
                }
                else {
                    context.cli.fatal(`The current project is a monorepo. The release script requires either lerna or the yarn package manager to handle this!`);
                }
            }
        }
        if (!(pack === null || pack === void 0 ? void 0 : pack.version)) {
            if (!lerna)
                context.cli.fatal("Missing property version from package.json!");
        }
        else if (!semver_1.default.valid(pack.version)) {
            context.cli.fatal(`Invalid version "${pack.version}" in package.json!`);
        }
        else {
            context.setData("version", pack.version);
        }
        // When in lerna mode, validate some legacy scripts
        let hasErrors = false;
        if (lerna && (0, typeguards_1.isObject)(pack.scripts)) {
            for (const [scriptName, script] of Object.entries(pack.scripts)) {
                if (script.includes("lerna version")) {
                    context.cli.error(`package.json script "${scriptName}" calls "lerna version". This script must be removed!`);
                    hasErrors = true;
                }
                else if (script.includes("release-script --lerna-check")) {
                    context.cli.error(`package.json script "${scriptName}" calls "release-script --lerna-check". This script must be removed!`);
                    hasErrors = true;
                }
                else if (script.includes("release-script --lerna")) {
                    context.cli.error(`package.json script "${scriptName}" calls "release-script --lerna-check". This script must be removed!`);
                    hasErrors = true;
                }
                else if (scriptName === "postversion" && script.includes("git push")) {
                    context.cli.error(`package.json script "${scriptName}" calls "git push". Pushing is handled by the release script. The script must be removed or changed!`);
                    hasErrors = true;
                }
            }
        }
        if (!hasErrors)
            context.cli.log(`package.json ok ${context.cli.colors.green("âœ”")}`);
        // Remember package.json contents
        context.setData("package.json", pack);
    }
    async executeEditStage(context) {
        const newVersion = context.getData("version_new");
        const pack = context.getData("package.json");
        if (context.argv.dryRun) {
            context.cli.log(`Dry run, would update package.json version from ${context.cli.colors.blue(pack.version)} to ${context.cli.colors.green(newVersion)}`);
        }
        else {
            context.cli.log(`updating package.json version from ${context.cli.colors.blue(pack.version)} to ${context.cli.colors.green(newVersion)}`);
            pack.version = newVersion;
            const packPath = path_1.default.join(context.cwd, "package.json");
            await fs_extra_1.default.writeJson(packPath, pack, { spaces: 2 });
        }
    }
    async executeEditStageYarnMonorepo(context) {
        const newVersion = context.getData("version_new");
        const pack = context.getData("package.json");
        // Force a publish of all packages if the version changed from a prerelease to a stable version
        const publishAll = getEffectivePublishAllFlag(context);
        // Figure out which packages changed (or which ones exist if all should be published)
        const updatePackages = await getUpdatePackages(context, publishAll, pack.version);
        // Work around https://github.com/yarnpkg/berry/issues/3868
        const packageJsonFiles = updatePackages.map((info) => path_1.default.join(context.cwd, info.location, "package.json"));
        const deleteStableVersions = async () => {
            for (const packPath of packageJsonFiles) {
                try {
                    const pack = await fs_extra_1.default.readJSON(packPath);
                    delete pack.stableVersion;
                    await fs_extra_1.default.writeJSON(packPath, pack, { spaces: 2 });
                }
                catch {
                    // ignore
                }
            }
        };
        if (context.argv.dryRun) {
            context.cli.log(`Dry run, would update monorepo version from ${context.cli.colors.blue(pack.version)} to ${context.cli.colors.green(newVersion)}. The following packages would be updated:${context.cli.colors.blue(updatePackages
                .filter((info) => info.location !== ".")
                .map((info) => `\nÂ· ${info.name}`)
                .join(""))}`);
        }
        else {
            context.cli.log(`updating monorepo version from ${context.cli.colors.blue(pack.version)} to ${context.cli.colors.green(newVersion)}. The following packages will be updated:${context.cli.colors.blue(updatePackages
                .filter((info) => info.location !== ".")
                .map((info) => `\nÂ· ${info.name}`)
                .join(""))}`);
            await deleteStableVersions();
            const commands = [
                publishAll
                    ? ["yarn", "workspaces", "foreach", "version", newVersion, "--deferred"]
                    : [
                        "yarn",
                        "changed",
                        "foreach",
                        `--git-range=v${pack.version}`,
                        "version",
                        newVersion,
                        "--deferred",
                    ],
                ["yarn", "version", newVersion, "--deferred"],
                ["yarn", "version", "apply", "--all"],
            ];
            for (const [cmd, ...args] of commands) {
                context.cli.logCommand(cmd, args);
                await context.sys.exec(cmd, args, { cwd: context.cwd });
            }
            await deleteStableVersions();
        }
    }
    async executeStage(context, stage) {
        if (stage.id === "check") {
            await this.executeCheckStage(context);
        }
        else if (stage.id === "edit") {
            // In lerna mode, we don't need to edit package.json
            const lerna = context.hasData("lerna") && !!context.getData("lerna");
            if (lerna)
                return;
            if (context.hasData("monorepo") && context.getData("monorepo") === "yarn") {
                await this.executeEditStageYarnMonorepo(context);
            }
            else {
                await this.executeEditStage(context);
            }
        }
        else if (stage.id === "commit") {
            if (context.hasData("monorepo") && context.getData("monorepo") === "yarn") {
                // Not necessary, when using yarn workspaces this was done during the edit stage
                return;
            }
            if (context.argv.updateLockfile) {
                context.cli.log(`updating lockfile...`);
                const pak = await (0, pak_1.detectPackageManager)({
                    cwd: context.cwd,
                    setCwdToPackageRoot: true,
                    requireLockfile: false,
                });
                // npm7+ deletes devDependencies unless we set this flag
                pak.environment = "development";
                if (!context.argv.dryRun) {
                    const result = await pak.install(undefined, {
                        ignoreScripts: true,
                    });
                    if (!result.success) {
                        context.cli.error(`Updating lockfile failed: ${result.stderr}`);
                    }
                }
            }
        }
    }
}
exports.default = PackagePlugin;
//# sourceMappingURL=index.js.map